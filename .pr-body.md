# TypeScript Workflow Support - DX Exploration

## Summary

This PR explores different approaches for creating workflows in TypeScript with a focus on:

âœ… **Simple, clear structure** - Easy to understand and write
âœ… **AI-friendly** - Optimized for AI code generation
âœ… **Reliable** - Built-in error handling and recovery
âœ… **Parseable** - mediar-app can easily render workflows in UI

## Three Approaches Explored

### Approach 1: YAML + TypeScript Functions (Simplest)

**Structure:**
- `workflow.yml` - Metadata config for UI parsing
- `workflow.ts` - Exported functions matching YAML steps

**Example:**
```yaml
# workflow.yml
steps:
  - id: open-app
    function: openNotepad
    description: Opens Notepad application
```

```typescript
// workflow.ts
export async function openNotepad(desktop: Desktop) {
  desktop.openApplication('notepad');
}
```

**Pros:**
- Extremely simple - just export functions
- Clear separation: YAML for config, TS for logic
- Easy for UI to parse YAML
- No build steps, no magic

**Cons:**
- Need separate YAML file
- Less type safety for step connections

**See:** `examples/ts-workflow-simple/` and `examples/ts-workflow-advanced/`

---

### Approach 2: Builder Pattern with YAML Metadata

**Structure:**
- `workflow.yml` - Metadata for UI
- `workflow.ts` - Uses builder pattern

**Example:**
```typescript
const workflow = defineWorkflow('id', 'name')
  .variable('userName', { type: 'string', default: 'World' })
  .step('open-app', 'Open Notepad', async (desktop) => {
    desktop.openApplication('notepad');
  })
  .build();
```

**Pros:**
- More structured than raw functions
- Type-safe variable definitions
- Chainable API

**Cons:**
- More boilerplate
- Still need YAML for UI
- Extra abstraction layer

---

### Approach 3: `createStep()` with AI Recovery (Most Powerful)

**Structure:**
- Single TypeScript file with advanced features
- AI-powered error recovery
- Production-ready patterns

**Example:**
```typescript
const loginStep = createStep({
  id: 'login',
  name: 'Login to Application',

  execute: async ({ desktop, variables, context, logger }) => {
    await desktop.locator('role:textbox|name:Username').fill(variables.username);
    await desktop.locator('role:button|name:Sign In').click();

    return { sessionId: 'abc123' };
  },

  // AI-powered error recovery
  onError: async ({ error, desktop, context, retry }) => {
    if (error.message.includes('Session conflict')) {
      await desktop.locator('role:button|name:Close Other Session').click();
      return retry();
    }

    // Use AI to analyze and recover
    const screenshot = await desktop.screenshot();
    const aiSuggestion = await context.ai.analyze({
      screenshot,
      goal: 'Login to the application',
      error: error.message,
    });

    if (aiSuggestion.canRecover) {
      for (const step of aiSuggestion.steps) {
        await desktop.execute(step);
      }
      return retry();
    }

    return { recoverable: false };
  },

  // Heuristic fallback
  fallback: async ({ desktop }) => {
    await desktop.restartApp();
    return { success: true };
  },

  // Error classification
  classifyError: (error) => {
    if (error.message.includes('Invalid credentials')) {
      return { type: 'permanent', shouldRetry: false };
    }
    return { type: 'temporary', shouldRetry: true, maxRetries: 3 };
  },
});

export const workflow = createWorkflow({
  id: 'production-workflow',
  name: 'Production Workflow with AI Recovery',
  variables: { username: { type: 'string', required: true } },
})
  .step(loginStep)
  .step(processData)
  .onError(async ({ error, step, context }) => {
    await moveToFailed(context.variables.file, { error, step });
  })
  .onSuccess(async ({ context }) => {
    await moveToProcessed(context.variables.file);
  });
```

**Pros:**
- Built-in error recovery patterns
- AI-powered error analysis
- Production-ready (handles file management, retries, classification)
- Type-safe throughout
- Composable and testable
- Inspired by Vercel/Mastra/Inngest but optimized for Terminator

**Cons:**
- More complex API
- Requires implementing AI integration
- Steeper learning curve

**See:** `examples/ts-workflow-with-recovery/` and `ADVANCED_DX_PROPOSAL.md`

---

## Key Insights from Production Workflow

Analyzed production workflow with 40+ files:

**Common Patterns Found:**
- Error classification (permanent vs temporary)
- File management (move to processed/failed folders)
- Retry logic with max attempts
- Duplicate detection
- State sharing between steps
- Heuristic error recovery

**Pain Points:**
- 40+ separate .js files - hard to maintain
- Repetitive error handling in every file
- Manual error classification (188 lines in one file)
- No type safety
- Hard to test

**How Approach 3 Addresses This:**
- Single workflow file with all steps
- Built-in error classification
- Automatic retry logic
- AI-powered recovery
- Full TypeScript type safety
- Easy to test (steps are pure functions)

---

## Files Changed

### Documentation
- `TYPESCRIPT_WORKFLOW_PROPOSAL.md` - Core proposal and structure
- `TYPESCRIPT_WORKFLOW_EXPLORATION.md` - Detailed comparison and analysis
- `ADVANCED_DX_PROPOSAL.md` - Advanced features (AI recovery, error handling)

### Examples

**Simple Example** (`examples/ts-workflow-simple/`):
- Basic YAML + TypeScript pattern
- 3 steps, 2 variables
- ~150 lines total
- Perfect for beginners

**Advanced Example** (`examples/ts-workflow-advanced/`):
- Organized steps in separate files
- State sharing via context
- Type-safe variables
- 9 steps with error handling

**Production Example** (`examples/ts-workflow-with-recovery/`):
- AI-powered error recovery
- Error classification
- Heuristic fallbacks
- File management
- Real-world patterns

---

## Recommended Approach

**Start with Approach 1** (YAML + Functions) because:
1. âœ… Simplest to implement
2. âœ… Easy for developers to understand
3. âœ… Easy for mediar-app UI to parse
4. âœ… No complex abstractions

**Evolve to Approach 3** (createStep with AI Recovery) because:
1. âœ… Production-ready patterns
2. âœ… Built-in reliability features
3. âœ… AI-friendly for code generation
4. âœ… Handles real-world complexity

We can support **both** approaches:
- Approach 1 for simple workflows
- Approach 3 for production workflows with error recovery

---

## Next Steps

**Phase 1: Core Implementation**
- [ ] Implement Approach 1 (YAML + Functions)
- [ ] Build YAML parser
- [ ] Build function executor
- [ ] Test with mediar-app UI

**Phase 2: Advanced Features**
- [ ] Implement Approach 3 (createStep API)
- [ ] Add error classification
- [ ] Add retry logic
- [ ] Add state management

**Phase 3: AI Integration**
- [ ] AI error analysis
- [ ] AI recovery suggestions
- [ ] Screenshot + tree analysis
- [ ] Automatic error classification

**Phase 4: Production**
- [ ] File management utilities
- [ ] Duplicate detection
- [ ] Observability/metrics
- [ ] Convert real production workflow

---

## Questions to Answer

1. Which approach should we prioritize first?
2. Should we support both YAML + TS and pure TS workflows?
3. How should AI integration work? (API design, model selection)
4. Should error recovery be opt-in or built-in by default?
5. How do we handle workflow versioning and migration?

---

## Benefits Over Original PR 318

**Original PR 318:**
- 69 files changed, 2,476 additions
- Complex JS/TS parser (1,027 lines)
- Multiple framework compatibility layers
- Builder pattern with abstractions

**This Exploration:**
- 22 files changed, 1,425 additions
- No complex parser needed (YAML is simple)
- Focused on Terminator-specific needs
- Multiple approaches explored
- Production patterns from real workflow

---

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
